/*
 * roboteq_rs232_RTU_Interface.h
 *
 *  Created on: 18 AÄŸu 2021
 *      Author: nesat
 */

#ifndef ROBOTEQ_RS232_RTU_INTERFACE_H_
#define ROBOTEQ_RS232_RTU_INTERFACE_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "main.h"
#include "stdint.h"
#include "stdbool.h"

typedef struct{
 uint8_t slaveAddress;
 uint16_t timeout;
 UART_HandleTypeDef *huart;
 uint16_t delayTime;
}roboteq_Modbus_RTU;

static const uint8_t modbus_crc_hi[] = {
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
};
static const uint8_t modbus_crc_lo[] = {
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2,
0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04,
0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8,
0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6,
0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10,
0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE,
0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA,
0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C,
0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0,
0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62,
0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE,
0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C,
0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 0xB6, 0x76,
0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A,
0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86,
0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

//slave address
#define ROBOTEQ_SLAVE_ADDRESS	0X01

//Command Mapping
#define COMMAND_P	0X0020	//Go to Absolute Desired Position
#define COMMAND_S	0x0040	//Set Motor Speed (close loop)
#define COMMAND_C	0x0060	//Set Encoder Counters
#define COMMAND_CB	0x0080	//Set Brushless Counter (close loop)
#define COMMAND_VAR	0x00A0	//Set User Variable
#define COMMAND_AC	0x00C0	//Set Acceleration
#define COMMAND_DC	0x00E0	//Set Deceleration
#define COMMAND_DS	0x0100	//Set all Digital Out bits
#define COMMAND_D1	0x0120	//Set Individual Digital Out bits
#define COMMAND_D0	0x0140	//Reset Individual Digital Out bits
#define COMMAND_R	0x0300	//MicroBasic Run
#define COMMAND_H	0x0160	//Load Home counter
#define COMMAND_EX	0x0180	//Emergency Stop
#define COMMAND_MG	0x01A0	//Emergency Stop Release
#define COMMAND_MS	0x01C0	//Stop in all modes
#define COMMAND_PR	0x01E0	//Go to Relative Desired Position
#define COMMAND_PX	0x0200	//Next Go to Absolute Desired Position
#define COMMAND_PRX	0x0220	//Next Go to Relative Desired Position
#define COMMAND_AX	0x0240	//Next Acceleration
#define COMMAND_DX	0x0260	//Next Deceleration
#define COMMAND_B	0x02A0	//Set User Boolean Variable
#define COMMAND_SX	0x0280	//Next Velocity
#define COMMAND_CG	0x0000	//Set Motor Command via CAN
#define COMMAND_RC	0x02C0	//Set Pulse Out
#define COMMAND_EES	0x02E0	//Save Configuration in EEPROM
#define COMMAND_AO	0x0320	//
#define COMMAND_TX	0x0340	//
#define COMMAND_TV	0x0360	//
#define COMMAND_CSW	0x0380	//
#define COMMAND_PSW	0x03A0	//
#define COMMAND_ASW	0x03C0	//Set SSI Sensor Counter

//Query Mapping
#define QUERY_A		0x2000	//Read Motor Amps
#define QUERY_M		0x2020	//Read Motor Command Applied
#define QUERY_P		0x2040	//Read Motor Power Output Applied
#define QUERY_S		0x2060	//Read Encoder Motor Speed in RPM
#define QUERY_C		0x2080	//Read Encoder Counter Absolute
#define QUERY_CB	0x20A0	//Read Absolute Brushless Counter
#define QUERY_VAR	0x20C0	//Read User Integer Variable
#define QUERY_SR	0x20E0	//Read Encoder Speed Relative
#define QUERY_CR	0x2100	//Read Encoder Count Relative
#define QUERY_BCR	0x2120	//Read Brushless Count Relative
#define QUERY_BS	0x2140	//Read BL Motor Speed in RPM
#define QUERY_BSR	0x2160	//Read BL Motor Speed as 1/1000 of Max RPM
#define QUERY_BA	0x2180	//Read Battery Amps
#define QUERY_V		0x21A0	//Read Volts
#define QUERY_D		0x21C0	//Read Digital Inputs
#define QUERY_F		0x21E0	//Read Temperature
#define QUERY_T		0x2200	//Read Feedback
#define QUERY_FS	0x2220	//Read Status Flags
#define QUERY_FF	0x2240	//Read Fault Flags
#define QUERY_B		0x22A0	//Read User Boolean Variable
#define QUERY_DO	0x2260	//Read Digital Output Status
#define QUERY_E		0x2280	//Read Closed Loop Error
#define QUERY_CIS	0x22C0	//Read Internal Serial Command
#define QUERY_CIA	0x22E0	//Read Converted Analog Command
#define QUERY_CIP	0x2300	//Read Internal Pulse Command
#define QUERY_TM	0x2320	//Read Time
#define QUERY_K		0x2340	//Read Spektrum Receiver
#define QUERY_DR	0x2360	//Read Destination Reached
#define QUERY_MA	0x2380	//Read Field Oriented Control Motor Amps
#define QUERY_MGD	0x23A0	//Read Magsensor Track Detect
#define QUERY_MGT	0x23C0	//Read Magsensor Track Position
#define QUERY_MGM	0x23E0	//Read Magsensor Markers
#define QUERY_MGS	0x2400	//Read Magsensor Status
#define QUERY_MGY	0x2420	//Read Magsensor Gyroscope
#define QUERY_FM	0x2440	//Read Runtime Status Flag
#define QUERY_HS	0x2460	//Read Hall Sensor States
#define QUERY_LK	0x2480	//

#define QUERY_TR	0x24A0	//
#define QUERY_QO	0x24C0	//
#define QUERY_EO	0x24E0	//
#define QUERY_RMA	0x2500	//
#define QUERY_RMG	0x2520	//
#define QUERY_RMM	0x2540	//
#define QUERY_ML	0x2560	//
#define QUERY_TS	0x2580	//
#define QUERY_MRS	0x25A0	//
#define QUERY_MZ	0x25C0	//
#define QUERY_PK	0x25E0	//
#define QUERY_RF	0x2600	//
#define QUERY_GY	0x2620	//
#define QUERY_ANG	0x2640	//
#define QUERY_SCC	0x2660	//
#define QUERY_ICL	0x2680	//
#define QUERY_FC	0x26A0	//
#define QUERY_SL	0x26C0	//
#define QUERY_FIN	0x26E0	//
#define QUERY_MGX	0x2700	//
#define QUERY_BSC	0x2740	//
#define QUERY_SS	0x2780	//
#define QUERY_SSR	0x27A0	//
#define QUERY_CSS	0x27C0	//
#define QUERY_CSR	0x27E0	//
#define QUERY_BMC	0x2820	//
#define QUERY_BMF	0x2840	//
#define QUERY_BMS	0x2860	//
#define QUERY_DI	0x28A0	//
#define QUERY_AI	0x28C0	//
#define QUERY_AIC	0x28E0	//
#define QUERY_PI	0x2900	//
#define QUERY_PIC	0x2920	//


 /*Modbus RTU Format:
  * Name		Lenght(bytes)		Desc
  * Address		1					Node Adress
  * Function	1					Function code
  * Data		n					n is the number of data bytes, it depends on function
  * Crc			2					Cyclic redundancy check (CRC-16-IBM) (msb first)
  * Address */

 /* Function Code 		Register Type
  * 1					Read Coil
  * 2					Read Discrete Input
  * 3					Read Holding Registers
  * 4					Read Input Registers
  * 5 					Write Single Coil
  * 6					Write Single Holding Register
  * 15 					Write Multiple Coils
  * 16 					Write Multiple Holding Registers
  * */
 enum{
	 READ_COIL=0x01,
	 READ_DISCRETE_INPUT,
	 READ_HOLDING_REGISTER,
	 READ_INPUT_REGISTER,
	 WRITE_SINGLE_COIL,
	 WRITE_SINGLE_HOLDING_REGISTER,
	 WRITE_MULTIPLE_COIL=0x0F,
	 WRITE_MULTIPLE_HOLDING_REGISTER
 };

 enum{
	 MOTOR_CHANNEL_1=0x01,
	 MOTOR_CHANNEL_2
 };
roboteq_Modbus_RTU roboteq_Modbus_RTU_create(  UART_HandleTypeDef *huart,
 		uint16_t timeout, uint8_t slaveAddress);
uint16_t roboteq_rs232_RTU_calcCRC(const uint8_t *p, uint16_t length);
bool roboteq_Modbus_RTU_write(roboteq_Modbus_RTU *drv,uint8_t funcCode,uint16_t registerAdd,
		uint8_t channel,uint32_t value);
uint32_t roboteq_Modbus_RTU_read(roboteq_Modbus_RTU *drv,uint8_t funcCode,uint16_t registerAdd,
		uint8_t channel);
uint32_t roboteq_Modbus_RTU_read1(roboteq_Modbus_RTU *drv,uint8_t funcCode,uint16_t registerAdd,
		uint8_t channel);

bool roboteq_Modbus_RTU_Motor_Channel1_set_speed(roboteq_Modbus_RTU *drv,int32_t value);
bool roboteq_Modbus_RTU_Motor_Channel2_set_speed(roboteq_Modbus_RTU *drv,int32_t value);
int32_t roboteq_Modbus_RTU_Motor_Channel1_get_Encoder(roboteq_Modbus_RTU *drv);
int32_t roboteq_Modbus_RTU_Motor_Channel2_get_Encoder(roboteq_Modbus_RTU *drv);

bool roboteq_Modbus_RTU_Motor_Channel2_EmergencyStop(roboteq_Modbus_RTU *drv);
bool roboteq_Modbus_RTU_Motor_Channel2_EmergencyStopRelease(roboteq_Modbus_RTU *drv);


bool roboteq_Modbus_RTU_Motor_Channel1_set_Encoder(roboteq_Modbus_RTU *drv,int32_t value);
bool roboteq_Modbus_RTU_Motor_Channel2_set_Encoder(roboteq_Modbus_RTU *drv,int32_t value);

#ifdef __cplusplus
}
#endif
#endif /* ROBOTEQ_RS232_RTU_INTERFACE_H_ */
